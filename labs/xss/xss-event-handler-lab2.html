<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>XSS Event Handler Lab â€“ 60 Levels (No Hints)</title>
  <style>
    :root {
      --fg: #111; --muted:#666; --line:#e5e7eb; --bg:#fff; --ac:#111827;
    }
    *{box-sizing:border-box}
    body{font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg);margin:24px}
    h1{margin:0 0 12px;font-size:26px}
    .top{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    select{padding:8px 10px;border:1px solid var(--line);border-radius:10px}
    .wrap{margin-top:14px}
    .level{display:none}
    .level.visible{display:block}
    textarea{width:100%;min-height:72px;padding:10px;border:1px solid var(--line);border-radius:12px}
    .row{display:grid;gap:10px;grid-template-columns:1fr 1fr}
    .btn{padding:10px 14px;border:1px solid var(--line);border-radius:12px;background:#f9fafb;cursor:pointer}
    .btn:hover{background:#f3f4f6}
    iframe{width:100%;height:240px;border:1px solid var(--line);border-radius:12px;background:#fff}
    .muted{color:var(--muted);font-size:12px}
    .badge{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid var(--line)}
  </style>
</head>
<body>
  <h1>ðŸ§ª XSS Event Handler Lab â€“ <span id="ttl"></span> Levels</h1>
  <div class="top">
    <label for="levelSel" class="badge">Select Level</label>
    <select id="levelSel"></select>
    <span class="muted">Goal: trigger <code>alert(document.domain)</code> or <code>alert(window.origin)</code> to unlock next level.</span>
  </div>

  <div class="wrap" id="levels"></div>

  <script>
  // ===== CONFIGURATION =====
  const TOTAL_LEVELS = 60; // \o/
  document.getElementById('ttl').textContent = TOTAL_LEVELS;

  // Event pools (for banning per level without revealing in UI)
  const COMMON_EVENTS = [
    'onclick','onerror','onload','onmouseover','onmouseenter','onmouseleave','onmousemove','onmouseout','oncontextmenu',
    'onfocus','onblur','onchange','oninput','onkeydown','onkeyup','onkeypress','onsubmit','onreset','ondblclick',
    'onwheel','onscroll','onplay','onpause','onended','oncanplay','oncanplaythrough','onvolumechange'
  ];
  const RARE_EVENTS = [
    'onanimationstart','onanimationend','onanimationiteration','ontransitionstart','ontransitionend','ontransitionrun',
    'onpointerdown','onpointerup','onpointermove','onpointerenter','onpointerleave','ongotpointercapture','onlostpointercapture',
    'ontouchstart','ontouchend','ontouchmove','oncopy','oncut','onpaste','ondrag','ondragstart','ondragend','ondragover','ondrop',
    'ondurationchange','onratechange','onseeked','onseeking','onstalled','onsuspend','ontimeupdate','ontoggle','onabort'
  ];

  // Context templates for injecting the (sanitized) payload in different sinks
  // NOTE: No hints in UI; only the resulting DOM will expose context to observant players.
  const CONTEXTS = [
    // 0: raw innerHTML drop
    (s) => `<div class="out">${s}</div>`,
    // 1: inside attribute (double quotes)
    (s) => `<img alt="${s}" src=x onload="/*maybe*/">`,
    // 2: inside attribute (single quotes)
    (s) => `<img title='${s}' src=x onload='/*maybe*/'>`,
    // 3: unquoted attribute
    (s) => `<img data-x=${s} src=x>`,
    // 4: inside textarea (requires breakout)
    (s) => `<textarea>${s}</textarea>`,
    // 5: inside HTML comment (requires breakout)
    (s) => `<!-- ${s} --><div class=pad></div>`,
    // 6: SVG context
    (s) => `<svg xmlns="http://www.w3.org/2000/svg"><text>${s}</text></svg>`,
    // 7: within <a> text & attribute nearby
    (s) => `<a href="#" class=lnk>${s}</a>`,
    // 8: inside video tag children
    (s) => `<video controls width=320>${s}</video>`,
    // 9: inside details/summary
    (s) => `<details><summary>more</summary>${s}</details>`,
    // 10: inside button text
    (s) => `<button>${s}</button>`,
    // 11: table context
    (s) => `<table><tr><td>${s}</td></tr></table>`,
    // 12: select/option context
    (s) => `<select><option>${s}</option></select>`,
    // 13: form action adjacent
    (s) => `<form><input name=q value="${s}"></form>`,
    // 14: pre/code
    (s) => `<pre><code>${s}</code></pre>`,
  ];

  // Per-level configuration
  // We synthesize 60 levels by combining contexts + filters. No hints are shown.
  const levels = Array.from({length: TOTAL_LEVELS}, (_,i)=>{
    const n = i+1;
    // Rotate contexts to keep variety
    const ctxIdx = n % CONTEXTS.length;

    // Base bans: progressively ban common/rare events
    const banCountCommon = Math.floor(n/6); // grows over time
    const banCountRare = Math.floor(n/10);
    const bannedEvents = new Set([
      ...COMMON_EVENTS.slice(0, banCountCommon),
      ...RARE_EVENTS.slice(0, banCountRare)
    ]);

    // Progressive extra constraints
    const constraints = {
      noQuotes: (n % 7 === 0),          // remove quotes occasionally
      squashWhitespace: (n % 5 === 0),  // collapse whitespace
      stripAutofocus: (n % 8 === 0),
      stripJsScheme: (n % 9 === 0),     // remove javascript:
      stripClosingTags: (n % 11 === 0), // remove </...>
      forceLower: (n % 13 === 0),
      stripEquals: (n % 17 === 0),      // remove '=' once in a while
    };

    return { id:n, ctxIdx, bannedEvents:[...bannedEvents], constraints };
  });

  // ===== RENDER UI =====
  const sel = document.getElementById('levelSel');
  const container = document.getElementById('levels');
  const unlocked = new Set([1]);

  for (const L of levels){
    const opt = document.createElement('option');
    opt.value = L.id; opt.textContent = `Level ${L.id}`; opt.disabled = L.id!==1; sel.appendChild(opt);

    const div = document.createElement('div');
    div.id = `level-${L.id}`; div.className = `level${L.id===1?' visible':''}`;
    div.innerHTML = `
      <div class=row>
        <div>
          <textarea id="in-${L.id}" placeholder="Inject payload here..."></textarea>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button class=btn onclick="runLevel(${L.id})">Run</button>
            <button class=btn onclick="resetFrame(${L.id})">Reset</button>
          </div>
        </div>
        <div>
          <iframe sandbox="allow-scripts allow-modals" id="frame-${L.id}"></iframe>
        </div>
      </div>
    `;
    container.appendChild(div);
  }

  sel.addEventListener('change', ()=>{
    const v = +sel.value;
    for (const L of levels){
      document.getElementById(`level-${L.id}`).classList.toggle('visible', L.id===v);
    }
  });

  // ===== SANITIZER PIPELINE =====
  function applyBans(levelId, input){
    const L = levels[levelId-1];
    let s = String(input);

    // Remove banned event handler attributes (case-insensitive)
    if (L.bannedEvents.length){
      const re = new RegExp(`\\s(?:${L.bannedEvents.map(e=>e.replace(/on/,'on')).join('|')})\\s*=\\s*([^>\\s"']+|\"[^\"]*\"|'[^']*')`, 'gi');
      s = s.replace(re, '');
    }

    // Constraints
    if (L.constraints.stripAutofocus){ s = s.replace(/autofocus/gi,''); }
    if (L.constraints.stripJsScheme){ s = s.replace(/javascript\s*:/gi,''); }
    if (L.constraints.forceLower){ s = s.toLowerCase(); }
    if (L.constraints.stripClosingTags){ s = s.replace(/<\/(script|img|svg|textarea|video|a|button|details|table|select|form|pre|code|div)[^>]*>/gi,''); }
    if (L.constraints.noQuotes){ s = s.replace(/[\"\']/g,''); }
    if (L.constraints.stripEquals){ s = s.replace(/=/g,''); }
    if (L.constraints.squashWhitespace){ s = s.replace(/\s+/g,' '); }

    // Prevent breaking parent <script> in the sandbox wrapper
    s = s.replace(/<\/script/gi,'<\\/script');
    return s;
  }

  function renderContext(levelId, sanitized){
    const L = levels[levelId-1];
    const tpl = CONTEXTS[L.ctxIdx] || CONTEXTS[0];
    return `<!DOCTYPE html><html><body>
      <script>
        // Intercept alert to check solve condition
        const oldAlert = window.alert;
        window.alert = function(msg){
          try{
            const ok = [document.domain, window.origin];
            if(ok.includes(msg)){
              parent.postMessage({type:'solved', level:${levelId}}, '*');
            }
          }catch(e){}
          return oldAlert.apply(window, arguments);
        };
      <\/script>
      ${tpl(sanitized)}
    </body></html>`;
  }

  // ===== RUNTIME =====
  function runLevel(levelId){
    const input = document.getElementById(`in-${levelId}`).value || '';
    const frame = document.getElementById(`frame-${levelId}`);
    const sanitized = applyBans(levelId, input);
    const html = renderContext(levelId, sanitized);
    frame.srcdoc = html;
  }
  window.runLevel = runLevel;

  function resetFrame(levelId){
    const frame = document.getElementById(`frame-${levelId}`);
    frame.srcdoc = '<!DOCTYPE html><html><body></body></html>';
  }
  window.resetFrame = resetFrame;

  // Unlock flow
  function unlockNext(levelId){
    if(levelId < TOTAL_LEVELS && !unlocked.has(levelId+1)){
      unlocked.add(levelId+1);
      const idx = Array.from(sel.options).findIndex(o=>+o.value===levelId+1);
      if(idx>=0){ sel.options[idx].disabled = false; }
      alert(`âœ… Level ${levelId} solved. Level ${levelId+1} unlocked.`);
    } else if (levelId === TOTAL_LEVELS) {
      alert(`ðŸŽ‰ Congrats! All ${TOTAL_LEVELS} levels solved.`);
    }
  }

  window.addEventListener('message', (ev)=>{
    if(ev?.data?.type==='solved' && Number.isInteger(ev.data.level)){
      unlockNext(ev.data.level);
    }
  });

  // Prevent selecting locked levels with mouse wheel etc.
  sel.addEventListener('mousedown', ()=>{
    for (const o of sel.options){
      const v = +o.value; if(!unlocked.has(v)) o.disabled = true;
    }
  });


  // ===== LOCAL STORAGE SAVE/LOAD =====
function saveProgress(){
  localStorage.setItem('xssEventLabProgress', JSON.stringify({
    unlocked: [...unlocked]
  }));
}

function loadProgress(){
  try {
    const data = JSON.parse(localStorage.getItem('xssEventLabProgress'));
    if(!data || !data.unlocked) return;
    data.unlocked.forEach(lvl => {
      unlocked.add(lvl);
      const opt = Array.from(sel.options).find(o => +o.value === lvl);
      if(opt) opt.disabled = false;
    });
    // Select the last unlocked level automatically
    const lastLevel = Math.max(...data.unlocked);
    sel.value = lastLevel;
    sel.dispatchEvent(new Event('change'));
  } catch(e){ console.error(e); }
}

// Auto-load progress on page load
loadProgress();

// Hook saveProgress into unlocking levels
const origUnlockNext = unlockNext;
unlockNext = function(levelId){
  origUnlockNext(levelId);
  saveProgress();
};
  
  </script>
</body>
</html>
